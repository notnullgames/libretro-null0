#!/usr/bin/env deno run --allow-net

// this will generate js wrapper for love API

// TODO: I don't like this wrapping style. all input/outputs should be wrapped for passing over wasm with their own functions

// make params docstring for a function variant
const funcDocArgs = variant => `

${variant.arguments.map(a => `@param ${a.name} (${a.type}) - ${a.description}`).join('\n')}
${variant.returns ? `@returns ${(variant.returns.length ? 'object' : variant.returns[0].type)}` : ''}
`

const love = await fetch('https://raw.githubusercontent.com/love2d-community/love-api/gh-pages/love-api.json').then(r => r.json())

console.log(`/*\nnull0, based on love version ${love.version}\n*/\n`)
console.log('const love = {}\nexport default love')

for (const mod of love.modules) {
  console.log(`\n\n/*\n${mod.name.toUpperCase()}\n\n${mod.description}\n*/\n`)
  console.log(`love.${mod.name} = {}`)
  for (const f of mod.functions) {
    // find the best (most arguments) overloaded function
    let func = f.variants.at(0)
    func.arguments ||= []
    if (f.variants.length > 1) {
      for (const v of f.variants) {
        v.arguments ||= []
        if (v.arguments.length > func.arguments.length) {
          func = v
          func.arguments ||= []
        }
      }
    }

    const args = JSON.stringify((func.arguments || []).map(a => [a.name, a.type]))
    const ret = JSON.stringify((func.returns || []).map(a => [a.name, a.type]))
    const argsIn = (func.arguments || []).map(a => a.name).join(', ')

    console.log(`\n/*\n${f.description}\n${funcDocArgs(func)}\n*/`)
    console.log(`love.${mod.name}.${f.name} = (${argsIn}) => call('${mod.name}_${f.name}', [${argsIn}], [${args}, ${ret}])`)
  }
  console.log(`

function call(name, args, types) {}

`)
}
